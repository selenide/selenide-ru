---
layout: post
title: "Реальный опыт с Selenide: покупка авиабилетов"
description: ""
category:
header-text: "тестируем airtickets.ru"
tags: []
---
{% include JB/setup %}

Привет!

Сегодня мы протестируем сайт [airtickets.ru](http://airtickets.ru).

Для разнообразия попробуем использовать шаблон PageObject, причём в разных вариациях:

* PageObject a'la Selenide style, [предложенный Андреем Солнцевым](http://ru.selenide.org/documentation/page-objects.html)
* классический PageObject
* PageObject с блоками (a'la HtmlElements)

### Что тестируем

Тест покупает авиабилеты СПб-Москва туда и обратно, вводя все необходимые значения,
и доходит до кнопки “Купить” после заполнения данных кредитной карточки.

Вот как это выглядит:

<center>
<iframe src="//www.youtube.com/embed/xS1KxNYgRsk" height="473" width="630" allowfullscreen="" frameborder="0"></iframe>
</center>

<br/>

## Как это работает
Давайте посмотрим, как этот тест устроен изнутри.

Проект на гитхабе: https://github.com/selenide-examples/airtickets.ru


### Что такое паттерн PageObject
PageObject - это способ работы с Web UI, при котором селекторы(локаторы) элементов задаются в отдельном классе.
Делается это для того, чтобы при изменении структуры html достаточно было обновлять селекторы всего в одном месте и не искать их по всему коду. 

#### Какие у нас страницы
Как видно из видео, мы работаем с 5-ю страницами. 

В самом тесте (класс TestBuyingTickets) описана логика работы всего теста. 
Из названия методов понятно, что делает каждая строчка. Посмотрим поподробнее на некоторые из них:

первая строка теста, открываем страницу и в этой же строчке “засовываем” в переменную 
`firstPageDirection` все данные об элементах/логике первой страницы. 
Теперь мы можем выполнить нужный нам метод, благодаря тому, что Selenide будет 
пытаться находить нужные нам селекторы в браузере:

```java
  FirstPageDirection firstPageDirection = 
    Selenide.open("http://www.airtickets.ru/bileti-aeroflot?gclid=CNzJ_-DQw8UCFcL3cgodeKwA0w", FirstPageDirection.class);
```

и далее последовательно выполняем необходимые нам действия:

* указать город отправления: `firstPageDirection.addDirectionFrom("Санкт", "LED");`
* указать город прибытия: `firstPageDirection.addDirectionTo("Москва", "MOW");`
* ...

стоит пояснить, зачем нужен цикл while - иногда после выбора рейсов и нажатия кнопки “далее” на второй странице может выпасть редкое сообщение о том, 
что рейсы не доступны, и предложение выбрать другие рейсы. 
Этот цикл как раз проверяет, что это сообщение не появилось. 
Если оно появится, то цикл будет повторять выбор билета, пока сообщение будет появляться.
Окончанием теста является проверка, что кнопка “Купить” отображена. 
В Selenide это делается очень просто, благодаря множеству условий на различные проверки элементов. 
Из самого названия метода понятно, что он проверяет:

```java
  fifthPage.getButton().shouldBe(Condition.visible);
```

Первые три страницы реализованы в виде "селенидовских" PageObject. 
Т.е. делаем отдельные классы для каждой страницы (FirstPageDirection, SecondPageVariants, ...)
и в каждом описываем логику, которая нам нужна, в виде отдельных методов. 
При этом селекторы необходимых элементов прописываются в методах. 
Например, добавить пункт отправления на первой странице (класс FirstPageDirection):

```java
  public void addDirectionFrom(String city, String airport) {
    $("#from").setValue(city);
    $("#autocomplete").$(withText(airport)).click();
  }
```

По умолчанию $ (поиск элемента по селектору) принимает как аргумент CSS селектор. 
Поэтому `$("#from")` - означает “найти элемент с ID “from”. 
Можете убедиться в том, что input “Откуда” имеет среди аттрибутов именно такой ID - 
откройте в любом браузере страницу сервиса http://www.airtickets.ru/bileti-aeroflot?gclid=CNzJ_-DQw8UCFcL3cgodeKwA0w, наведите мышку 
на строку ввода пункта отправления “Откуда” и в контекстном меню (правая кнопка мыши) выберите “Просмотреть код”. 
Браузер откроет html код страницы и подсветит нужный нам input. 
Среди атрибутов этого элемента есть id="from".
 
Далее вносим значение в этот input с помощью метода Selenide.setValue(String). 
Почему это написано в одну строку? Потому что первая часть `$("#from")` означает, что мы получили SelenideElement, 
у которого есть метод setValue(String). Также Вы можете использовать как аргумент `$()` и `xpath`, тогда вызов будет выглядеть так: `$(By.xpath(....))`.

Также в `FirstPageDirection` вы можете увидеть вспомогательные методы, которые нужны только для работы с первой страницей - 
получение текущего месяца из System. 
Это нужно для проверки, что сервис автоматически подставляет как месяц отправления либо текущий месяц, либо следующий. 
Проверка осуществляется с помощью assert’ов в тесте.Это, например, строка:

```java
Assert.assertThat("Месяц отправления не равен текущему месяцу или следующему месяцу", 
  firstPageDirection.getMonthDeparture(), anyOf(is(firstPageDirection.getCurrentMonth()), is(firstPageDirection.getNextMonth())));
```

Кстати, крайне рекомендую освоить `assertThat` от `hamcrest` (которая уже давно в составе JUnit).
Отличие `assertThat` от `assertTrue`, `assertEquals` и др. в читаемости, а также в том, что вы всегда при непрохождении 
проверки будете получать в логи фразы типа: пришло “то-то”, а ожидали “то-то”. Очень удобно.

В PageObject второй страницы (`SecondPageVariants`) используется селенидовский метод `$$`.
Он возвращает массив всех элементов, найденных по заданному селектору. 
Есть задача случайно выбрать рейс из предлагаемых. 
Для этого находим на странице все рейсы: 

```java
List<SelenideElement> radioList = priceTable.$$(".radio");
```

Здесь опять использован CSS-селектор, только в это случае мы ищем элементы по аттрибуту class. 
Получаем массив всех существующих на странице .radio и выбираем среди них случайный:
 
```java
SelenideElement radio = radioList.get((int)(Math.random() * (radioList.size()-1)));
```

(Немного упростил описание, но разобраться в том, как действительно отрабатывает логика, несложно.)

Четвертая страница (`FourthPagePassengerInfo`) реализована классическим PageObject c применением блоков. 
Блоки - это отдельные группы элементов на странице, которые для простоты обработки можно вынести в отдельный PageObject (использовать инкапсуляцию). 
На четвертой странице у нас есть два фрейма, для заполнения информации о пассажирах и контактных данных. 
В начале класса мы говорим, что на странице нас интересуют два фрейма, задаем для них селекторы с Selenium аннотацией FindBy:

```java
  @FindBy(xpath = "(.//*[@class='frame'])[1]")
  private FramePassengerInfo passengerInfo;

  @FindBy(xpath = "(.//*[@class='frame'])[2]")
  private FrameContactPersonInfo contactPersonInfo;
```

Как видите, тип фреймов у нас не `WebElement` и не `SelenideElement`, а соответствующий для каждого фрейма блок, 
который вы можете посмотреть в классе `ForthPagePassengerInfoElements`. 
Каждый блок описан в классическом PageObject, с аннотацией `@FindBy` и своими уникальными методами. 
Для того, чтобы показать, что каждый фрейм - это блок, необходимо наследовать `ElementsContainer` 
(в объявлении класса : `public class FramePassengerInfo extends ElementsContainer`).

Итоги:

1. Те, кто ранее писал тесты на чистом Selenium, надеюсь, увидели, что Selenide позволяет значительно сократить написание тестов.

2. Паттерн PageObject, как и свойственно любому шаблону, является только идеей подхода написания кода. 
Вы можете описать селекторы в начале с аннотацией @FindBy (классический вариант), 
или же вы можете написать PageObject как предлагает Андрей Солнцев - страница содержит методы, внутри которых пишутся селекторы. 
Вы даже можете создать синглтон, который будет содержать мапу со всеми селекторами вашего проекта. 
И в описании логики тестов выдергивать селекторы из мапы и вставлять их как аргумент в селенидовский $.
(именно такое решение применил у себя на проекте, где очень много элементов с похожими названиями, мало уникальных классов и айдишников). 
Главное, старайтесь описывать селектор для конкретного элемента в одном месте. 
Чтобы вы или тот автоматизатор, что придет на ваше место в будущем, могли это место 
легко отыскать и изменить селектор, если разработчики решат поменять html структуру.


Василий Ковальченко
