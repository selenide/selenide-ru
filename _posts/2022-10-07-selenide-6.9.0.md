---
layout: post
title: "Вышла Selenide 6.9.0"
description: ""
category:
header-text: "Подменяем результаты"
tags: []
---
{% include JB/setup %}

<br>
# Привет!

Позвольте прервать ваш думскроллинг хорошей новостью. 

Вы выпустили [Selenide 6.9.0](https://github.com/selenide/selenide/milestone/166?closed=1)!
В основном прокачали прокси и обновили селениум.

* [Подменяем ответ сервера в прокси](#proxy-mock-response)
* [Заголовок авторизации](#secure-authorization-header)
* [Подкрутили имя прокси хоста](#resolve-proxy-hostname)
* [Обновились на Selenium 4.5.0](#upgrade-to-selenium-4.5.0)
* [Выкинули поддержку Opera](#remove-opera-support)
* [Убрали `getAlias` из отчётов](#do-not-log-get-alias)
* [Вернули настройку "connection timeout"](#restore-setting-connection-timeout)
* [Новости](#news)
{: .blogpost-menu}

### Научили прокси подменять ответ сервера {#proxy-mock-response}

Как вы знаете, селенид умеет запускать свой встроенный прокси между браузером и тестируемым приложением. До сих пор мы
использовали его в основном для отслеживания запросов (логирования, скачивания файлов), но теперь ещё и добавили возможность
подменить ответ сервера. Это удобно, например, чтобы замокать ответ какого-то сервиса.

Давайте рассмотрим на каком-нибудь простеньком абстрактном примере.

#### Пример

Допустим, вы тестируете сайт, показывающий результаты референдума. 
Это html-страница по адресу, скажем, https://referendum.ru, которая обращается к сервису https://cik.ru и тянет с него 
json с результатами голосования. 

Поскольку результаты заранее неизвестны, а сайт протестировать нужно здесь и сейчас, мы хотим проверить, как он будет 
выглядеть в разных пограничных случаях (corner cases). 

#### Тест
```java
open();
getSelenideProxy().responseMocker().mockText("cik-mock",
    urlStartsWith(GET, "https://cik.ru/api/gov/no/referendum"), 
    () -> "{votes: 2133326, for: 99.23, against: 0.77}");

open("https://referendum.ru");
$("#votesFor").shouldHave(text("99.23%"));
$("#h3").shouldHave(text("Не только порадовали, но и удивили"));
```

#### Детали
Остановимся подробнее на первом параметре `cik-mock`. Это *имя* мока. 
Нужно оно для того, чтобы после теста его отменить (чтобы случайно не повлиять на следующие тесты):
```java
@AfterEach
void tearDown() {
  getSelenideProxy().responseMocker().reset("cik-mock");
}
```

Ну или для надёжности можно отменить *все* моки:

```java
@AfterEach
void tearDown() {
  getSelenideProxy().responseMocker().resetAll();
}
```

#### Ограничения
Если страница и сервис работают на одном домене, ограничений нет.
А вот если страница обращается к сервису на другом домене, то мок сработает только при выполнении условий:
* страница и сервис бегают на https (не http)
* сервис работает и физически доступен из прокси

#### В общем
Использование моков - мощная техника, позволяющая вам проверять разные пограничные условия, которые иначе повторить 
сложно или невозможно ("146% голосов за", "никто не явился на выборы", "сервис недоступен" и т.д.)

> Не стесняйтесь своего желания что-то подправлять, подчищать, добавлять. 
> Будет так, как вы захотите. 

См. [issue 1254](https://github.com/selenide/selenide/issues/1254) и [PR 1978](https://github.com/selenide/selenide/pull/1978).

<br>

### Посылаем заголовок авторизации только нужному домену {#secure-authorization-header}

Некоторые сайты, которые вам приходится тестировать, закрыты от внешнего мира с помощью BasicAuth.
Селенид позволяет их открыть с помощью метода open с доп. параметрами:
```java
open("https://referendum.ru/admin", BASIC, 
             new BasicAuthCredentials("vlastelin", "gojda!!!"));
```

Этот метод умеет обходить BasicAuth:
* если прокси выключен - добавлением логина-пароля в URL, 
* а если прокси включен - добавлением заголовка `Authorization` в запросы от браузера к серверу. 

Но вот незадача. Недавно мы обнаружили, что селенид слал заголовок `Authorization` не только тестируемому приложению, но 
и всем сторонним сервисам, к которым оно могло обращаться (например, S3 или Google authentication).

Теперь селенид будет посылать заголовок `Authorization` только на нужный домен, но и вам придётся указать этот домен в конструкторе:

```java
open("https://referendum.ru/admin", BASIC, 
             new BasicAuthCredentials("referendum.ru", "vlastelin", "gojda!!!"));
```

См. [issue 1974](https://github.com/selenide/selenide/issues/1974) и [PR 1975](https://github.com/selenide/selenide/pull/1975).

<br>

### Подкрутили имя прокси хоста {#resolve-proxy-hostname}

Когда вы включаете прокси в селениде (например, через `Configuration.proxyEnabled = true`), 
селенид запускает встроенный прокси-сервер на случайном порту. И открывает браузер с указанием использовать 
прокси-сервер `HOST:PORT`. Вопрос, какой HOST тут использовать?

До сих пор по умолчанию использовался результат команды `ClientUtil.getConnectableAddress()`, но с этого релиза 
будет использоваться `new NetworkUtils().getNonLoopbackAddressOfThisMachine()`. Мне лень разбираться, в чём там их специфика, но 
на моём компе они иногда выдают разный результат:
* `new NetworkUtils().getNonLoopbackAddressOfThisMachine()` -> `192.168.0.18`
* `ClientUtil.getConnectableAddress()` -> `127.0.0.1`

И первый однозначно лучше, когда браузер бежит на другой машине или в контейнере.
Под адресом `127.0.0.1` прокси просто не будет виден с другой машины.

> Кстати, если этот механизм почему-то вам не помог, вы всегда можете явно задать имя хоста для прокси через настройку 
> `Configuration.proxyHost = "my.comp.eu";`

См. [PR 1970](https://github.com/selenide/selenide/pull/1970).

<br>

### Обновились на Selenium 4.5.0 {#upgrade-to-selenium-4.5.0}

Из заметных изменений:
* удалили поддержку браузера Opera
* добавили альтернативную реализацию вебдрайвера на JDK 11 HTTP client вместо Netty client
* Добавили проверки на `disabled` в класс `Select`
* Убрали имя хоста из селениумовских эксепшенов
> цуко, я просил об этом [ещё в 2015 году](https://github.com/SeleniumHQ/selenium/issues/489)!!!

См. [ченджлог](https://github.com/SeleniumHQ/selenium/blob/trunk/java/CHANGELOG) и 
[PR 1967](https://github.com/selenide/selenide/pull/1967).

<br>

### Выкинули поддержку Opera {#remove-opera-support}

Следствие предыдущего пункта. Селениум выкинул - и мы выкинули. 
Тестировать в опере не имеет особого смысла, т.к. это по сути тот же Chrome. 
Если очень хочется - можно, просто используйте chromedriver.

См. [PR 1967](https://github.com/selenide/selenide/pull/1967).

<br>

### Убрали `getAlias` из отчётов {#do-not-log-get-alias}

Спасибо [Reserved Word](https://github.com/reserved-word) за [PR 1971](https://github.com/selenide/selenide/pull/1971).

<br>

### Вернули настройку "connection timeout" {#restore-setting-connection-timeout}

Это мало кому нужно, так что смело пропускайте.

Когда-то у нас было две настройки для http клиента вебдрайвера: "connection timeout" и "read timeout". 
Первую пришлось убрать при обновлении на Selenium 4, потому что её там выпилили.
Теперь её там реанимировали, ну и мы реанимировали.
{: .small}

См. [PR 1977](https://github.com/selenide/selenide/pull/1977).

<br>

### Обновили зависимости {#update-dependencies}

* LittleProxy from 2.0.12 to 2.0.13
* slf4j from 2.0.2 to 2.0.3

<br>

### Новости {#news}

* Доклад Сергея Брита [Selenide + Playwright Java = объединяй и властвуй](https://www.youtube.com/watch?v=obsJWnBsYwk&ab_channel=SQAANALYSTSECR) - конференция SQA Days EA, 01.10.2022
* Доклад Алексея Виноградова [Spinner-driven-development](https://www.youtube.com/watch?v=MLxf9q9qXu4&ab_channel=%D0%A2%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8%D0%B2%D0%9A%D0%BE%D0%BD%D1%82%D1%83%D1%80%D0%B5)

<br>

Айтишники, учите английский [по ирландским комикам](https://www.youtube.com/watch?v=laIGavOMcw8&ab_channel=FoilArmsandHog)! 

<br>

[Андрей Солнцев](http://asolntsev.github.io/)

ru.selenide.org
