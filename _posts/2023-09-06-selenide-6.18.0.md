---
layout: post
title: "Вышла Selenide 6.18.0"
description: ""
category:
header-text: "Актуальные тексты"
tags: []
---
{% include JB/setup %}

Все уже перевернули календарь?  
Тогда при свете костров рябин можете обновиться на [Selenide 6.18.0](https://github.com/selenide/selenide/milestone/190?closed=1).

* [Показываем актуальные тексты в коллекциях](#show-actual-texts-in-collections)
* [Обновили Selenium с 4.11.0 на 4.12.1](#update-to-selenium-4.12.1)
* [Вернули BasicAuth через DevTools](#restore-basic-auth-via-cdp)
* [Добавили метод `$$.getOptions()`](#add-method-get-options)
* [Метод `getFocusedElement()` обленился](#get-focused-element-lazy-loaded)
* [Поля `SelenideAppiumElement` в пэдж обжектах](#support-appium-elements-in-page-objects)
* [Точечный скроллинг в мобилках](#exact-scroll-in-appium)
* [Не наследовать пэдж обжект от `ElementsContainer`](#no-elements-container-for-page-object)
* [Обновили зависимости](#update-dependencies)
* [Статистика](#statistics)
{: .blogpost-menu}
  <br>


### Показываем актуальные тексты в коллекциях {#show-actual-texts-in-collections}

В релизе 6.16.0 мы [ускорили проверки коллекций](/2023/07/02/selenide-6.16.0/#speedup-collection-checks).
```java
$$(".troubles").shouldHave(texts(
  "Всё не то", "всё не так", 
  "ты мой друг", "я твой враг"));
```

Одна из оптимизаций была такая: если размер коллекции не совпадает, то селенид даже не начинает проверять тексты элементов,
а сразу кидает ошибку:
```java
List size mismatch: expected: = 4, actual: 3
```

Но люди стали жаловаться, что хотелось бы увидеть, какие же там всё-таки были тексты. 
Похоже, это тот случай, когда удобство важнее скорости. А падают ваши тесты не так уж часто, ведь правда? ;)

Поэтому с этого релиза будем показывать и размер, и тексты:
```java
List size mismatch (expected: 4, actual: 3)
Actual (3): [Журавлей белый клин, твоя дочь и мой сын]
Expected (4): [Всё не то, всё не так, ты мой друг, я твой враг]
```

См. [issue 2434](https://github.com/selenide/selenide/issues/2434) и [PR 2456](https://github.com/selenide/selenide/pull/2456).

<br>

### Обновили Selenium с 4.11.0 на 4.12.1 {#update-to-selenium-4.12.1}

Ченджлог [здесь](https://github.com/SeleniumHQ/selenium/blob/trunk/java/CHANGELOG).
Среди прочего, там исправили злополучный [дедлок в devtools](https://github.com/SeleniumHQ/selenium/issues/12576), из-за которого нам пришлось выпустить предыдущий релиз.

См. [PR 2452](https://github.com/selenide/selenide/pull/2452).

<br>

### Вернули BasicAuth через DevTools {#restore-basic-auth-via-cdp}

В релизе 6.16.0 мы запилили
[авторизацию BasicAuth через механизм `HasAuthentication` в браузерах семейства Chromium](/2023/07/02/selenide-6.16.0/#improve-basic-auth-in-chromium-browsers).

Потом нам пришлось её откатить из-за вышеупомянутого дедлока в вебдрайвере. Теперь селениум обновили, дедлок исправили, и мы вернули авторизацию взад. 

См. [issue 2336](https://github.com/selenide/selenide/issues/2336), [PR 2358](https://github.com/selenide/selenide/pull/2358) и [PR 2452](https://github.com/selenide/selenide/pull/2452).

<br>

### Добавили метод `$$.getOptions()` {#add-method-get-options}

В селениде уже был метод `$$.getSelectedOptions()` - он возвращает _выбранные_ опции элемента `<select>`. 
А теперь мы добавили похожий метод `$$.getOptions()`, чтобы можно было проверить _все_ его опции.

```java
$("select").getOptions()
  .shouldHave(texts("день прощанья", "костры рябин", "обещания"));

$("select").selectOption("день прощанья");

$("select").getSelectedOptions()
  .shouldHave(texts("день прощанья"));
```
См. [issue 2445](https://github.com/selenide/selenide/issues/2445) и [PR 2446](https://github.com/selenide/selenide/pull/2446).

<br>

### Метод `getFocusedElement()` обленился {#get-focused-element-lazy-loaded}

Теперь метод `getFocusedElement()` возвращает `SelenideElement`, а не `WebElement`.  

Что автоматически означает ленивую загрузку и прочие плюшки.  
А ещё вы можете использовать для него стандартные should-проверки:

```java
Selenide.getFocusedElement()
  .shouldHave(tagName("input"), id("otpCode"));
```
См. [PR 2454](https://github.com/selenide/selenide/pull/2454).

<br>

### Добавили поддержку полей `SelenideAppiumElement` в пэдж обжектах {#support-appium-elements-in-page-objects}

Если вы пишете тесты для мобилок с нашим плагином `selenide-appium`, то теперь вы можете объявлять поля пэдж обжекта
с типом `SelenideAppiumElement`, вместо `SelenideElement`.

Это даёт дополнительные методы для мобилок: `hideKeyboard()`, `swipe()` и т.п. 

```java
class LoginPage {
  @AndroidFindBy(accessibility = "Username input field")
  SelenideAppiumElement login;

  @AndroidFindBy(accessibility = "Password input field")
  SelenideElement password;
  
  public void login() {
    password.swipeTo();
  }
}
```

См. [issue 2437](https://github.com/selenide/selenide/issues/2437) и [PR 2438](https://github.com/selenide/selenide/pull/2438).

<br>

### Точечный скроллинг в мобилках {#exact-scroll-in-appium}

Продолжая тему мобилок.
В плагине `selenide-appium` есть метод `scroll`:
```java
import static com.codeborne.selenide.appium.AppiumScrollOptions.with;

$.scroll(with(UP, 20)); // свайпать вверх, не больше 20 раз
```

А теперь ему в параметрах можно более точно указать начальную и конечную точку 
свайпа (в процентах от высоты экрана):
```java
import static com.codeborne.selenide.appium.AppiumScrollOptions.up;

$.scroll(up(10, 80)); // свайпать от точки 10% до точки 80%
```

Спасибо [qwez](https://github.com/qwez) за [PR 2449](https://github.com/selenide/selenide/pull/2449).

<br>

### Нельзя наследовать пэдж обжект от `ElementsContainer` {#no-elements-container-for-page-object}

Некоторые пользователи жаловались на такой вот странный ворнинг от селенида:
> WARN com.codeborne.selenide.impl.SelenidePageFactory - Cannot initialize field private com.codeborne.selenide.SelenideElement com.codeborne.selenide.ElementsContainer.self

Мы начали исследовать тему и поняли, что это происходит, если вы наследуете пэдж обжект от `ElementsContainer`:

```java
class LoginPage extends ElementsContainer {
}
```

Что на самом деле **не нужно**. Собственно, теперь и не получится. :)

Изначально `ElementsContainer` был задуман для того, чтобы объявлять компоненты _внутри_ пэдж обжекта:
```java
class LoginPage {
  @FindBy(id="weather")
  WeatherWidget weatherWidget;
}

class WeatherWidget extends ElementsContainer {
  @FindBy(id="temperature")
  SelenideElement temperature;
}
```

Просто уберите `extends ElementsContainer` из своего пэдж обжекта, и всё будет прекрасно работать. 

P.S. Дело в том, что это разные объекты с разной судьбой.
1. Пэдж обжекты вы можете создавать методом `LoginPage page = Selenide.page();`. И для этого им _не требуется_ наследоваться от `ElementsContainer`.
2. А вот поля этих пэдж обжектов надо наследовать от `ElementsContainer`, чтобы селенид знал, что в них надо тоже искать аннотации `@FindBy`.

См. [issue 2439](https://github.com/selenide/selenide/issues/2439) и [PR 2455](https://github.com/selenide/selenide/pull/2455).

<br>


### Обновили зависимости {#update-dependencies}
* bump LittleProxy from 2.0.19 to 2.0.20 (fixes a memory leak in Selenide proxy)
* update vulnerable jackson dependency - см. [PR 2442](https://github.com/selenide/selenide/pull/2442)

<br>

### Статистика {#statistics}

Количество ежемесячных скачиваний Селенида перевалило за 670 тыщ!

<center>
  <img src="{{ BASE_PATH }}/images/2023/09/selenide.downloads.png" width="800"/>
</center>

<br>
Такими темпами у нас будет всё всерьёз. Следующего второго сентября. 

<br>

[Андрей Солнцев](http://asolntsev.github.io/)

ru.selenide.org
